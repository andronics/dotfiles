#!/usr/bin/env zsh

name=$(basename $0)

# ------------------------------

# https://superuser.com/questions/1701385/simple-bluetooth-device-monitor-with-timestamps
# https://github.com/nickclyde/rofi-bluetooth.git

# ------------------------------

source "$(which _cat)"
source "$(which _func)"
source "$(which _jq)"
source "$(which _log)"

# ------------------------------

# Device C6:BF:20:96:A6:4E LE_WH-1000XM4
# Device C3:49:80:0F:58:66 LE_WH-1000XM4
# Device 94:DB:56:F5:8F:9E WH-1000XM4
# Device D8:0B:9A:04:93:BF Stephen's Tab S6

# ------------------------------

bt_cache_dir="${XDG_CACHE_HOME}/${name}"
bt_config_dir="${XDG_CONFIG_HOME}/${name}"
bt_data_dir="${XDG_DATA_HOME}/${name}"

# ------------------------------

[[ ! -d "${bt_cache_dir}" ]] && mkdir -p "${bt_cache_dir}" 
[[ ! -d "${bt_config_dir}" ]] && mkdir -p "${bt_config_dir}" 
[[ ! -d "${bt_data_dir}" ]] && mkdir -p "${bt_data_dir}"

# ------------------------------

bt_fifo="${bt_cache_dir}/bt.fifo"
bt_pid=

# ------------------------------

_bt() {

    # Check if bluetoothctl is available
    if ! command -v bluetoothctl &> /dev/null; then
        echo "Error: bluetoothctl is not installed." >&2
        exit 1
    fi

    # Check if expect is available
    if ! command -v expect &> /dev/null; then
        echo "Error: expect is not installed." >&2
        exit 1
    fi

    # Check if no arguments are provided - run in service mode
    [[ $# -eq 0 ]] && {

        # Service Mode
    
        log-info "running in service mode"

        log-debug "create FIFO for communication"
        [[ -p "${bt_fifo}" ]] && rm -f "${bt_fifo}"
        mkfifo "${bt_fifo}"

        log-debug "start bluetoothctl in background with FIFO"
        bluetoothctl < "${bt_fifo}" > "${bt_fifo}" 2>&1 &
        bt_pid=$!

        log-debug "trap cleanup on exit"
        trap _bt_svc_cleanup EXIT INT TERM

        log-info "power on and perform 10 second scan for devices"
        _bt_exec "power on"
        _bt_exec "scan on"
        
        for ((i=2; i>0; i--)); do
            printf "\r--- remaining: %2d seconds" "$i"
            sleep 1
        done
        printf "--- scan complete. processing   \n"
        

        log-debug "stop scanning and get devices"
        _bt_exec "scan off" > "${bt_fifo}"
        _bt_exec "devices" > "${bt_fifo}"
        sleep 2  # Allow time for device list to populate

        log-info "Discovered devices:"

        grep -o 'Device \([0-9A-Fa-f]\{2\}:\)\{5\}[0-9A-Fa-f]\{2\} .*' "${bt_fifo}" | while read -r line; do
            mac=$(echo "$line" | awk '{print $2}')
            name=$(echo "$line" | cut -d ' ' -f 3-)
            [ -z "$name" ] && name="Unknown"
            log-info "  - $name ($mac)"
        done


        # while true; do
        #     if read line < "${bt_fifo}"; then
        #         log-debug "received command: $line"
        #         _bt "$line"
        #     fi
        # done &

    } || {

        log-debug "command specified - running in command mode"

        _command=$1
        shift 2>/dev/null

        case "${_command}" in
            
            controller-default) _bt_controller_default "$@" ;;
            controller-list) _bt_controller_list "$@" ;;
            controller-select) _bt_controller_select "$@" ;;
            
            device-connect) _bt_device_connect "$@" ;;
            device-connected) _bt_device_connect "$@" ;;
            device-disconnect) _bt_device_disconnect "$@" ;;
            device-pair) _bt_device_pair "$@" ;;
            device-paired) _bt_device_paired "$@" ;;
            device-trust) _bt_device_trust "$@" ;;
            device-trusted) _bt_device_trusted "$@" ;;
            device-unpair) _bt_device_unpair "$@" ;;
            device-unpaired) _bt_device_unpaired "$@" ;;

            discover-disable) _bt_discover_disable "$@" ;;
            discover-enable) _bt_discover_enable "$@" ;;
            discover-state) _bt_discover_state "$@" ;;
            discover-toggle) _bt_discover_toggle "$@" ;;

            pairing-disable) _bt_pairing_disable "$@" ;;
            pairing-enable) _bt_pairing_enable "$@" ;;
            pairing-state) _bt_pairing_state "$@" ;;
            pairing-toggle) _bt_pairing_toggle "$@" ;;

            power-disable) _bt_power_disable "$@" ;;
            power-enable) _bt_power_enable "$@" ;;
            power-state) _bt_power_state "$@" ;;
            power-toggle) _bt_power_toggle "$@" ;;

            scan) _bt_power_toggle "$@" ;;

            scan-disable) _bt_scan_disable "$@" ;;
            scan-enable) _bt_scan_enable "$@" ;;
            scan-state) _bt_scan_state "$@" ;;
            scan-toggle) _bt_scan_toggle "$@" ;;

            *) log-warning "command '%s' unsupported" "${_command}" ;;

        esac

    }

}

# ------------------------------

_bt_exec() {

    # Execute a command in bluetoothctl
    if [[ -p "${bt_fifo}" ]]; then
        log-info "executing command: $1"
        echo "$1" > "${bt_fifo}"
    else
        log-error "FIFO not available. Is bluetoothctl running?"
        return 1
    fi

}

# ------------------------------

_bt_svc_cleanup() {

    # Cleanup function to remove temporary files or processes
    if [[ -n "$FIFO" && -p "$FIFO" ]]; then
        rm -f "$FIFO"
    fi

    # Kill any background processes if needed
    if [[ -n "$bt_pid" ]]; then
        kill $bt_pid 2>/dev/null
    fi

}

# ------------------------------

_bt_controller_default() {
    bluetoothctl list | grep '\[default\]' | cut -d ' ' -f 2
}

_bt_controller_list() {
    bluetoothctl list | cut -d ' ' -f 2
}

_bt_controller_select() {

    _controller=$1

    log-info "select controller '${_controller}'"
    bluetoothctl select "${_controller}"

}

# ------------------------------

_bt_device_connect() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_connected() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_disconnect() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_pair() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_paired() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_trust() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_trusted() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_unpair() {
    _func_unimplemented "${FUNCNAME}" 
}

_bt_device_untrust() {
    _func_unimplemented "${FUNCNAME}" 
}

# ------------------------------

_bt_discover_disable() {

    [[ $(_bt_discover_state) ]] && {
        log-info "disabling discover"
        bluetoothctl discoverable off
    }

}

_bt_discover_enable() {

     [[ ! $(_bt_discover_state) ]] && {
        log-info "enabling discover"
        bluetoothctl discoverable on
    }

}

_bt_discover_state() {

    bluetoothctl show | grep -q "Discoverable: yes" && return 0 || return 1

}

_bt_discover_toggle() {

    _bt_discover_state && _bt_discover_disable || _bt_discover_enable

}

# ------------------------------

_bt_pairing_disable() {

    [[ $(_bt_pairing_state) ]] && {
        log-info "disabling pairing"
        bluetoothctl pairable off
    }

}

_bt_pairing_enable() {

     [[ ! $(_bt_pairing_state) ]] && {
        log-info "enabling pairing"
        bluetoothctl pairable on
    }

}

_bt_pairing_state() {

    bluetoothctl show | grep -q "Pairable: yes" && return 0 || return 1

}

_bt_pairing_toggle() {

    _bt_pairing_state && _bt_pairing_disable || _bt_pairing_enable

}

# ------------------------------

_bt_power_disable() {

    [[ $(_bt_power_state) ]] && {
        log-info "disabling power"
        bluetoothctl power off
    }

}

_bt_power_enable() {

     [[ ! $(_bt_power_state) ]] && {
        log-info "enabling power"
        bluetoothctl power on
    }

}

_bt_power_state() {

    bluetoothctl show | grep -q "Powered: yes" && return 0 || return 1

}

_bt_power_toggle() {

    _bt_power_state && _bt_power_disable || _bt_power_enable

}

# ------------------------------

_bt_scan() {

    # Create FIFO for communication
    FIFO=$(mktemp -u)
    mkfifo "$FIFO"

    # Start bluetoothctl in background with FIFO
    bluetoothctl < "$FIFO" > "$FIFO" 2>&1 &
    bt_pid=$!

    cleanup() {
        kill $bt_pid 2>/dev/null
        rm -f "$FIFO"
        echo -e "\nScan stopped."
        exit
    }
    trap cleanup EXIT INT TERM

    # Initialize scanning
    echo "power on" > "$FIFO"
    echo "scan on" > "$FIFO"
    echo "Scanning for Bluetooth devices for 10 seconds. Press Ctrl+C to stop early..."

    # Scan for 10 seconds (or until interrupted)
    for ((i=10; i>0; i--)); do
        printf "\rTime remaining: %2d seconds" "$i"
        sleep 1
    done
    printf "\rScanning complete. Processing results...   \n"

    # Stop scanning and get devices
    echo "scan off" > "$FIFO"
    echo "devices" > "$FIFO"
    sleep 1  # Allow time for device list to populate

    # Process discovered devices
    echo "Discovered devices:"
    grep -o 'Device \([0-9A-Fa-f]\{2\}:\)\{5\}[0-9A-Fa-f]\{2\} .*' "$FIFO" | while read -r line; do
        mac=$(echo "$line" | awk '{print $2}')
        name=$(echo "$line" | cut -d ' ' -f 3-)
        [ -z "$name" ] && name="Unknown"
        echo "  - $name ($mac)"
    done

    echo "Scan completed."



}

# ------------------------------

_bt_scan_disable() {

    [[ $(_bt_scan_state) ]] && {
        log-info "disabling scanning"
        bluetoothctl scan off
    }

}

_bt_scan_enable() {

     [[ ! $(_bt_scan_state) ]] && {
        log-info "enabling scanning"
        bluetoothctl scan on
    }

}

_bt_scan_state() {

    bluetoothctl show | grep -q "Discovering: yes" && return 0 || return 1

}

_bt_scan_toggle() {

    _bt_scan_state && _bt_scan_disable || _bt_scan_enable

}

# ------------------------------

_bt "$@"