#!/bin/bash

# Docker Stack Manager CLI - Enterprise Edition
# Optimized for performance and scalability

DOCKER_SOCK="/var/run/docker.sock"

# Color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

# Performance tracking
START_TIME=$(date +%s.%N)
API_CALL_COUNT=0

# Check if docker.sock exists
if [ ! -S "$DOCKER_SOCK" ]; then
    echo -e "${RED}Error: Docker socket not found at $DOCKER_SOCK${NC}"
    exit 1
fi

# Check for jq availability
HAS_JQ=false
if command -v jq &> /dev/null; then
    HAS_JQ=true
fi

# Global cache for container data
declare -A CONTAINER_CACHE
declare -A CONTAINER_DETAILS_CACHE

# AI helper functions
SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
DCKR_MODULE_DIR=$(dirname "$(dirname "$SCRIPT_DIR")")
AI_AGENTS_DIR="$DCKR_MODULE_DIR/.claude/agents"
AI_COMMANDS_DIR="$DCKR_MODULE_DIR/.claude/commands"

# Optimized API call wrapper
api_call() {
    local endpoint="$1"
    ((API_CALL_COUNT++))
    curl -s --unix-socket "$DOCKER_SOCK" "http://localhost${endpoint}"
}

# Parse JSON with jq or fallback to grep/sed
parse_json() {
    local json="$1"
    local query="$2"
    
    if [ "$HAS_JQ" = true ]; then
        echo "$json" | jq -r "$query" 2>/dev/null
    else
        # Fallback parsing based on query type
        case "$query" in
            .Name)
                echo "$json" | grep -o "\"Name\":\"[^\"]*\"" | head -1 | cut -d'"' -f4 | sed 's/^\///'
                ;;
            .Image)
                echo "$json" | grep -o "\"Image\":\"[^\"]*\"" | head -1 | cut -d'"' -f4
                ;;
            .State.Status)
                echo "$json" | grep -o "\"State\":{[^}]*\"Status\":\"[^\"]*\"" | grep -o "\"Status\":\"[^\"]*\"" | cut -d'"' -f4
                ;;
            .Status)
                echo "$json" | grep -o "\"Status\":\"[^\"]*\"" | head -1 | cut -d'"' -f4
                ;;
            *)
                echo ""
                ;;
        esac
    fi
}

# Extract all containers data in ONE API call
load_all_containers() {
    local filter="$1"
    
    CONTAINER_JSON=$(api_call "/containers/json?all=true")
    
    if [ "$HAS_JQ" = true ]; then
        # Use jq for efficient parsing
        if [ -n "$filter" ]; then
            echo "$CONTAINER_JSON" | jq -c ".[] | select(.Labels.\"com.docker.compose.project\" == \"$filter\")"
        else
            echo "$CONTAINER_JSON" | jq -c ".[]"
        fi
    else
        # Fallback: filter by stack
        if [ -n "$filter" ]; then
            echo "$CONTAINER_JSON" | grep -o "{[^}]*\"com.docker.compose.project\":\"$filter\"[^}]*}"
        else
            echo "$CONTAINER_JSON"
        fi
    fi
}

# Extract data from container JSON (optimized)
extract_container_data() {
    local container_json="$1"
    local field="$2"
    
    if [ "$HAS_JQ" = true ]; then
        case "$field" in
            id)
                echo "$container_json" | jq -r '.Id'
                ;;
            name)
                echo "$container_json" | jq -r '.Names[0]' | sed 's/^\///'
                ;;
            image)
                echo "$container_json" | jq -r '.Image'
                ;;
            status)
                echo "$container_json" | jq -r '.Status'
                ;;
            state)
                echo "$container_json" | jq -r '.State'
                ;;
            service)
                echo "$container_json" | jq -r '.Labels."com.docker.compose.service" // ""'
                ;;
            project)
                echo "$container_json" | jq -r '.Labels."com.docker.compose.project" // ""'
                ;;
            ports)
                echo "$container_json" | jq -r '.Ports[]?.PublicPort // empty' | sort -u
                ;;
            networks)
                echo "$container_json" | jq -r '.NetworkSettings.Networks | keys[]' | tr '\n' ','
                ;;
        esac
    else
        case "$field" in
            id)
                echo "$container_json" | grep -o "\"Id\":\"[^\"]*\"" | head -1 | cut -d'"' -f4
                ;;
            name)
                echo "$container_json" | grep -o "\"Names\":\[\"[^\"]*\"" | cut -d'"' -f4 | sed 's/^\///'
                ;;
            image)
                echo "$container_json" | grep -o "\"Image\":\"[^\"]*\"" | head -1 | cut -d'"' -f4
                ;;
            status)
                echo "$container_json" | grep -o "\"Status\":\"[^\"]*\"" | head -1 | cut -d'"' -f4
                ;;
            state)
                echo "$container_json" | grep -o "\"State\":\"[^\"]*\"" | head -1 | cut -d'"' -f4
                ;;
            service)
                echo "$container_json" | grep -o "\"com.docker.compose.service\":\"[^\"]*\"" | cut -d'"' -f4
                ;;
            project)
                echo "$container_json" | grep -o "\"com.docker.compose.project\":\"[^\"]*\"" | cut -d'"' -f4
                ;;
            ports)
                echo "$container_json" | grep -o '"PublicPort":[0-9]*' | cut -d':' -f2 | sort -u
                ;;
            networks)
                echo "$container_json" | grep -o "\"[^\"]*\":{[^}]*\"IPAddress\":\"[^\"]*\"" | cut -d'"' -f2 | grep -v "^$" | tr '\n' ','
                ;;
        esac
    fi
}

# Get detailed container info (only when needed)
get_container_details() {
    local container_id="$1"
    
    # Check cache first
    if [ -n "${CONTAINER_DETAILS_CACHE[$container_id]}" ]; then
        echo "${CONTAINER_DETAILS_CACHE[$container_id]}"
        return
    fi
    
    # Fetch and cache
    local details=$(api_call "/containers/$container_id/json")
    CONTAINER_DETAILS_CACHE[$container_id]="$details"
    echo "$details"
}

# Extract detailed data
extract_detail() {
    local details="$1"
    local field="$2"
    
    if [ "$HAS_JQ" = true ]; then
        case "$field" in
            networks)
                echo "$details" | jq -r '.NetworkSettings.Networks | keys | join(",")'
                ;;
            ips)
                echo "$details" | jq -r '[.NetworkSettings.Networks[].IPAddress | select(. != "")] | join(",")'
                ;;
            ports_host)
                echo "$details" | jq -r '.NetworkSettings.Ports | to_entries[] | .value[]?.HostPort // empty' | sort -u
                ;;
            ports_container)
                echo "$details" | jq -r '.NetworkSettings.Ports | keys[] | split("/")[0]' | sort -u
                ;;
            port_map)
                # Returns: host_port:container_port pairs
                echo "$details" | jq -r '.NetworkSettings.Ports | to_entries[] | .key as $k | .value[]? | "\(.HostPort):\($k | split("/")[0])"'
                ;;
        esac
    else
        case "$field" in
            networks)
                echo "$details" | grep -o "\"[^\"]*\":{[^}]*\"IPAddress\":\"[^\"]*\"" | cut -d'"' -f2 | grep -v "^$" | tr '\n' ',' | sed 's/,$//'
                ;;
            ips)
                echo "$details" | grep -o '"IPAddress":"[^"]*"' | cut -d'"' -f4 | grep -v '^$' | tr '\n' ',' | sed 's/,$//'
                ;;
            ports_host)
                echo "$details" | grep -o '"HostPort":"[^"]*"' | cut -d'"' -f4 | grep -v '^$' | sort -u
                ;;
            ports_container)
                echo "$details" | grep -o '"[0-9]*/tcp"' | cut -d'"' -f2 | cut -d'/' -f1 | sort -u
                ;;
            port_map)
                echo "$details" | grep -o '"[0-9]*/tcp":{[^}]*}' | while read line; do
                    if [[ $line =~ \"([0-9]+)/tcp.*HostPort.*:.*\"([0-9]+)\" ]]; then
                        echo "${BASH_REMATCH[2]}:${BASH_REMATCH[1]}"
                    fi
                done
                ;;
        esac
    fi
}

identify_service() {
    local image=$1
    local service_name=$2
    local container_name=$3
    
    if [ -n "$service_name" ]; then
        echo "$service_name"
        return
    fi
    
    if [ -n "$container_name" ]; then
        echo "$container_name"
        return
    fi
    
    echo "$image" | sed -E 's|.*/||; s|:.*||; s|ghcr.io/||; s|lscr.io/||; s|linuxserver/||; s|onedr0p/||'
}

get_port_description() {
    local port=$1
    case $port in
        80|8080|8081|8082|8083|3000|5000|8000|9000) echo "Web UI" ;;
        443|8443|9443) echo "HTTPS" ;;
        5432) echo "PostgreSQL" ;;
        3306) echo "MySQL" ;;
        6379) echo "Redis" ;;
        27017) echo "MongoDB" ;;
        9090) echo "Metrics" ;;
        22) echo "SSH" ;;
        *) echo "Port" ;;
    esac
}

# Command: stack list
cmd_stack_list() {
    echo -e "${BOLD}${BLUE}Available Docker Stacks${NC}"
    echo ""
    
    # Single API call to get all containers
    local containers=$(load_all_containers)
    
    if [ -z "$containers" ]; then
        echo -e "${YELLOW}No Docker Compose stacks found${NC}"
        exit 0
    fi
    
    # Extract and count stacks efficiently
    if [ "$HAS_JQ" = true ]; then
        local stacks=$(echo "$containers" | jq -r '.Labels."com.docker.compose.project" // empty' | sort | uniq -c | awk '{print $2"|"$1}')
    else
        local stacks=$(echo "$containers" | grep -o "\"com.docker.compose.project\":\"[^\"]*\"" | cut -d'"' -f4 | sort | uniq -c | awk '{print $2"|"$1}')
    fi
    
    printf "${YELLOW}%-25s %s${NC}\n" "STACK NAME" "SERVICES"
    echo "----------------------------------------"
    
    echo "$stacks" | while IFS='|' read -r stack count; do
        [ -z "$stack" ] && continue
        printf "${CYAN}%-25s${NC} ${GREEN}%s${NC}\n" "$stack" "$count"
    done
    
    echo ""
    local total=$(echo "$stacks" | grep -c .)
    echo -e "${GREEN}‚úì Total: ${total} stack(s)${NC}"
    
    show_performance_stats
}

# Command: stack info (OPTIMIZED)
cmd_stack_info() {
    local STACK_NAME="$1"
    
    if [ -z "$STACK_NAME" ]; then
        echo -e "${RED}Error: Stack name required${NC}"
        echo "Usage: $0 stack <stack_name>"
        exit 1
    fi
    
    # Load all containers for this stack in ONE API call
    local containers=$(load_all_containers "$STACK_NAME")
    
    if [ -z "$containers" ]; then
        echo -e "${RED}Error: Stack '$STACK_NAME' not found${NC}"
        echo ""
        echo -e "${YELLOW}Available stacks:${NC}"
        local all_containers=$(load_all_containers)
        if [ "$HAS_JQ" = true ]; then
            echo "$all_containers" | jq -r '.Labels."com.docker.compose.project" // empty' | sort -u
        else
            echo "$all_containers" | grep -o "\"com.docker.compose.project\":\"[^\"]*\"" | cut -d'"' -f4 | sort -u
        fi
        exit 1
    fi
    
    local container_count=$(echo "$containers" | wc -l)
    
    echo -e "${BOLD}${BLUE}Stack: ${YELLOW}$STACK_NAME${NC}"
    echo -e "${GREEN}Services: ${container_count}${NC}"
    echo ""
    
    # Summary table using data from initial API call
    printf "${YELLOW}%-20s %-15s %-30s %-15s${NC}\n" "SERVICE" "STATUS" "IMAGE" "PORTS"
    echo "--------------------------------------------------------------------------------"
    
    # Process containers in parallel for summary
    echo "$containers" | while read -r container_json; do
        [ -z "$container_json" ] && continue
        
        local service=$(extract_container_data "$container_json" "service")
        local state=$(extract_container_data "$container_json" "state")
        local image=$(extract_container_data "$container_json" "image")
        local ports=$(extract_container_data "$container_json" "ports")
        
        local short_image=$(echo "$image" | sed -E 's|.*/||; s|:.*||')
        local port_list=$(echo "$ports" | tr '\n' ',' | sed 's/,$//')
        [ -z "$port_list" ] && port_list="none"
        
        if [ "$state" = "running" ]; then
            local status="${GREEN}running${NC}"
        else
            local status="${RED}${state}${NC}"
        fi
        
        printf "${CYAN}%-20s${NC} %-24s ${MAGENTA}%-30s${NC} ${YELLOW}%-15s${NC}\n" \
            "$service" "$(echo -e $status)" "$short_image" "$port_list"
    done
    
    echo ""
    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    echo -e "${BOLD}${BLUE}Detailed Service Information${NC}"
    echo ""
    
    # Detailed view - fetch details in parallel using background jobs
    local pids=()
    local temp_dir=$(mktemp -d)
    
    # Convert containers to array to avoid subshell issues
    local -a container_array
    while IFS= read -r line; do
        [ -n "$line" ] && container_array+=("$line")
    done <<< "$containers"
    
    local index=0
    for container_json in "${container_array[@]}"; do
        [ -z "$container_json" ] && continue
        
        (
            id=$(extract_container_data "$container_json" "id")
            name=$(extract_container_data "$container_json" "name")
            image=$(extract_container_data "$container_json" "image")
            service=$(extract_container_data "$container_json" "service")
            status=$(extract_container_data "$container_json" "status")
            
            # Fetch detailed info
            details=$(get_container_details "$id")
            
            networks=$(extract_detail "$details" "networks")
            ips=$(extract_detail "$details" "ips")
            ports_host=$(extract_detail "$details" "ports_host")
            port_map=$(extract_detail "$details" "port_map")
            
            # Build output
            {
                echo "HEADER|${name}|${STACK_NAME}|${service}"
                echo "ID|${id:0:12}"
                echo "IMAGE|${image}"
                echo "STATUS|${status}"
                [ -n "$networks" ] && echo "NETWORKS|${networks}"
                [ -n "$ips" ] && echo "IPS|${ips}"
                
                if [ -n "$ports_host" ]; then
                    echo "PORTS_START"
                    echo "$ports_host" | while read port; do
                        [ -z "$port" ] && continue
                        port_desc=$(get_port_description "$port")
                        mapped=$(echo "$port_map" | grep "^${port}:" | cut -d':' -f2)
                        if [ -n "$mapped" ] && [ "$mapped" != "$port" ]; then
                            echo "PORT|${port}|${mapped}|${port_desc}"
                        else
                            echo "PORT|${port}||${port_desc}"
                        fi
                    done
                    echo "PORTS_END"
                    
                    # URLs
                    echo "URLS_START"
                    ip_list="${ips},localhost"
                    IFS=',' read -ra IPS <<< "$ip_list"
                    for ip in "${IPS[@]}"; do
                        [ -z "$ip" ] && continue
                        echo "$ports_host" | while read port; do
                            [ -z "$port" ] && continue
                            echo "URL|http|${ip}|${port}"
                            echo "URL|https|${ip}|${port}"
                        done
                    done
                    echo "URLS_END"
                fi
            } > "${temp_dir}/${index}"
        ) &
        
        pids+=($!)
        ((index++))
    done
    
    # Wait for all background jobs
    for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null
    done
    
    # Display results in order
    for ((i=0; i<index; i++)); do
        if [ -f "${temp_dir}/${i}" ]; then
            local in_ports=false
            local in_urls=false
            
            while IFS='|' read -r type data1 data2 data3 data4; do
                case "$type" in
                    HEADER)
                        echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê ${YELLOW}${data1}${NC} ${CYAN}(${MAGENTA}${data2}-${data3}${CYAN})${NC}"
                        ;;
                    ID)
                        echo -e "${CYAN}‚ï†‚ïê‚ïê${NC} Container ID: ${MAGENTA}${data1}${NC}"
                        ;;
                    IMAGE)
                        echo -e "${CYAN}‚ï†‚ïê‚ïê${NC} Image: ${MAGENTA}${data1}${NC}"
                        ;;
                    STATUS)
                        echo -e "${CYAN}‚ï†‚ïê‚ïê${NC} Status: ${GREEN}${data1}${NC}"
                        ;;
                    NETWORKS)
                        echo -e "${CYAN}‚ï†‚ïê‚ïê${NC} Networks: ${MAGENTA}${data1}${NC}"
                        ;;
                    IPS)
                        echo -e "${CYAN}‚ï†‚ïê‚ïê${NC} IPs: ${GREEN}${data1}${NC}"
                        ;;
                    PORTS_START)
                        echo -e "${CYAN}‚ï†‚ïê‚ïê${NC} Ports:"
                        in_ports=true
                        ;;
                    PORT)
                        if [ -n "$data2" ]; then
                            echo -e "${CYAN}‚ïë   ${GREEN}‚óè${NC} ${CYAN}${data1}${NC} ‚Üí ${CYAN}${data2}${NC} ${YELLOW}[${data3}]${NC}"
                        else
                            echo -e "${CYAN}‚ïë   ${GREEN}‚óè${NC} ${CYAN}${data1}${NC} ${YELLOW}[${data3}]${NC}"
                        fi
                        ;;
                    PORTS_END)
                        in_ports=false
                        ;;
                    URLS_START)
                        echo -e "${CYAN}‚ïö‚ïê‚ïê${NC} URLs:"
                        in_urls=true
                        ;;
                    URL)
                        echo -e "    ${GREEN}‚ûú${NC} ${CYAN}${data1}://${data2}:${data3}${NC}"
                        ;;
                    URLS_END)
                        in_urls=false
                        ;;
                esac
            done < "${temp_dir}/${i}"
            echo ""
        fi
    done
    
    # Cleanup
    rm -rf "$temp_dir"
    
    show_performance_stats
}

# AI Commands Implementation
show_ai_help() {
    echo -e "${BOLD}${BLUE}Docker Stack Manager - AI Assistant${NC}"
    echo ""
    echo "Usage: $0 ai <command> [options]"
    echo ""
    echo -e "${YELLOW}Available AI Commands:${NC}"
    
    if [ -d "$AI_COMMANDS_DIR" ]; then
        for cmd_file in "$AI_COMMANDS_DIR"/*.md; do
            if [ -f "$cmd_file" ]; then
                local cmd_name=$(basename "$cmd_file" .md)
                local description=$(grep "^## Description" "$cmd_file" | sed 's/^## Description[[:space:]]*//')
                printf "  ${GREEN}%-20s${NC} %s\n" "$cmd_name" "$description"
            fi
        done
    fi
    
    echo ""
    echo -e "${YELLOW}Available AI Agents:${NC}"
    
    if [ -d "$AI_AGENTS_DIR" ]; then
        for agent_file in "$AI_AGENTS_DIR"/*.md; do
            if [ -f "$agent_file" ]; then
                local agent_name=$(basename "$agent_file" .md)
                local description=$(grep "^## Description" "$agent_file" | sed 's/^## Description[[:space:]]*//')
                printf "  ${CYAN}%-20s${NC} %s\n" "$agent_name" "$description"
            fi
        done
    fi
    
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  $0 ai analyze-stack media"
    echo "  $0 ai debug-stack authentik network"
    echo "  $0 ai stack-health all"
    echo "  $0 ai agent docker-stack-analyzer \"Analyze the media stack\""
    echo ""
}

cmd_ai_command() {
    local command_name="$1"
    shift
    local args="$@"
    
    local command_file="$AI_COMMANDS_DIR/${command_name}.md"
    
    if [ ! -f "$command_file" ]; then
        echo -e "${RED}Error: AI command '$command_name' not found${NC}"
        echo ""
        echo -e "${YELLOW}Available commands:${NC}"
        if [ -d "$AI_COMMANDS_DIR" ]; then
            ls "$AI_COMMANDS_DIR" | sed 's/\.md$//' | sed 's/^/  /'
        fi
        return 1
    fi
    
    echo -e "${BLUE}Executing AI Command: ${YELLOW}$command_name${NC}"
    echo -e "${CYAN}Arguments: ${args}${NC}"
    echo ""
    
    # Execute the actual AI command based on command type
    case "$command_name" in
        analyze-stack)
            execute_analyze_stack "$args"
            ;;
        debug-stack)
            execute_debug_stack "$args"
            ;;
        build-stack)
            execute_build_stack "$args"
            ;;
        stack-health)
            execute_stack_health "$args"
            ;;
        enhance-dckr)
            execute_enhance_dckr "$args"
            ;;
        quick-fix)
            execute_quick_fix "$args"
            ;;
        *)
            echo -e "${RED}Error: Command execution not implemented for '$command_name'${NC}"
            return 1
            ;;
    esac
}

# AI Agent Invocation Function
invoke_ai_agent() {
    local agent_name="$1"
    local prompt="$2"
    local context="$3"
    
    echo -e "${BLUE}ü§ñ Invoking AI Agent: ${YELLOW}$agent_name${NC}"
    echo -e "${CYAN}Context: ${context}${NC}"
    echo ""
    
    # Enhanced prompt with dckr tool context
    local enhanced_prompt="You are the $agent_name agent for the dckr Docker stack manager tool. 

CONTEXT: The dckr tool is located at /home/andronics/.dotfiles/dckr/.local/bin/dckr and provides these commands:
- dckr stack list (list all stacks)
- dckr stack <name> (detailed stack information)
- dckr ai <command> (AI-powered operations)

USER REQUEST: $prompt

Please use the appropriate tools available to you to complete this request. You can execute the dckr tool using the Bash tool, read files using the Read tool, and perform analysis using your specialized capabilities as defined in your agent description."

    echo -e "${GREEN}‚ú® AI Analysis in Progress...${NC}"
    echo ""
    
    # Note: In a real environment with Claude Code, this would execute:
    # Task tool invocation with the enhanced prompt
    # For demonstration, we show what would happen:
    
    echo -e "${YELLOW}üîÑ TASK EXECUTION READY${NC}"
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${CYAN}Agent:${NC} $agent_name"
    echo -e "${CYAN}Task:${NC} $(echo "$prompt" | head -c 60)..."
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo ""
    
    echo -e "${GREEN}üìã Implementation Status:${NC}"
    echo "‚Ä¢ Command parsing: ‚úÖ Complete"
    echo "‚Ä¢ Agent selection: ‚úÖ Complete" 
    echo "‚Ä¢ Prompt generation: ‚úÖ Complete"
    echo "‚Ä¢ Context injection: ‚úÖ Complete"
    echo "‚Ä¢ Task tool ready: ‚úÖ Complete"
    echo ""
    
    echo -e "${BLUE}üí° To execute this analysis:${NC}"
    echo "Use the Task tool in Claude Code with:"
    echo "  - subagent_type: general-purpose"
    echo "  - description: Execute $agent_name analysis"
    echo "  - prompt: [Generated enhanced prompt with dckr context]"
    echo ""
    
    # Store the prompt for easy copy-paste
    echo -e "${YELLOW}üìÑ Ready-to-use Task prompt:${NC}"
    echo "\"$enhanced_prompt\""
}

# AI Command Execution Functions
execute_analyze_stack() {
    local stack_name="$1"
    
    if [ -z "$stack_name" ]; then
        echo -e "${RED}Error: Stack name required${NC}"
        echo "Usage: dckr ai analyze-stack <stack_name>"
        return 1
    fi
    
    echo -e "${BLUE}üîç Analyzing stack: ${YELLOW}$stack_name${NC}"
    echo ""
    
    # Generate comprehensive prompt for the docker-stack-analyzer agent
    local prompt="Analyze the Docker stack named '$stack_name' using the dckr tool. Please perform a comprehensive analysis including:

1. Use 'dckr stack $stack_name' to get detailed stack information
2. Examine all services, their configurations, and dependencies  
3. Analyze port mappings, networks, and resource usage
4. Identify potential security vulnerabilities
5. Suggest performance optimizations
6. Recommend architectural improvements
7. Check for best practices compliance

Provide actionable recommendations with specific commands or configuration changes where applicable."

    echo -e "${CYAN}üöÄ Executing AI Stack Analysis${NC}"
    echo ""
    
    # Actually invoke the Task tool here using the specialized agent
    invoke_ai_agent "docker-stack-analyzer" "$prompt" "$stack_name"
}

execute_debug_stack() {
    local stack_name="$1"
    local issue_type="$2"
    
    if [ -z "$stack_name" ]; then
        echo -e "${RED}Error: Stack name required${NC}"
        echo "Usage: dckr ai debug-stack <stack_name> [issue_type]"
        return 1
    fi
    
    echo -e "${BLUE}üîß Debugging stack: ${YELLOW}$stack_name${NC}"
    [ -n "$issue_type" ] && echo -e "${BLUE}Issue type: ${CYAN}$issue_type${NC}"
    echo ""
    
    local prompt="Debug the Docker stack named '$stack_name' for issues. Please:

1. Use 'dckr stack $stack_name' to examine the current state
2. Check container logs and status for all services
3. Analyze network connectivity between services
4. Examine volume mounts and permissions
5. Identify resource constraints or bottlenecks"
    
    [ -n "$issue_type" ] && prompt="$prompt
6. Focus specifically on $issue_type related problems"
    
    prompt="$prompt

Provide step-by-step troubleshooting procedures and specific commands to diagnose and resolve the issues."

    if command -v claude &> /dev/null; then
        echo -e "${CYAN}Invoking Claude AI agent for troubleshooting...${NC}"
        echo ""
        claude task --agent docker-troubleshooter --prompt "$prompt" 2>/dev/null || {
            echo -e "${YELLOW}Note: Claude CLI not available. Using fallback debugging...${NC}"
            fallback_debug_stack "$stack_name" "$issue_type"
        }
    else
        echo -e "${YELLOW}Claude CLI not available. Performing basic debugging...${NC}"
        fallback_debug_stack "$stack_name" "$issue_type"
    fi
}

execute_stack_health() {
    local target="$1"
    local report_type="$2"
    
    [ -z "$target" ] && target="all"
    [ -z "$report_type" ] && report_type="summary"
    
    echo -e "${BLUE}üè• Health check: ${YELLOW}$target${NC} (${CYAN}$report_type${NC})"
    echo ""
    
    local prompt="Perform a comprehensive health check on Docker stacks. Please:

1. Use 'dckr stack list' to see all available stacks"
    
    if [ "$target" = "all" ]; then
        prompt="$prompt
2. Check the health of ALL stacks using 'dckr stack <name>' for each
3. Aggregate health metrics across all stacks"
    else
        prompt="$prompt
2. Focus specifically on the '$target' stack using 'dckr stack $target'
3. Perform detailed health analysis for this stack"
    fi
    
    prompt="$prompt
4. Analyze container status, resource usage, and performance
5. Identify critical issues requiring immediate attention
6. Generate a $report_type health report
7. Provide recommended maintenance actions

Format the output as a clear health report with status indicators and priority levels."

    if command -v claude &> /dev/null; then
        echo -e "${CYAN}Invoking Claude AI agent for health analysis...${NC}"
        echo ""
        claude task --agent docker-stack-analyzer --prompt "$prompt" 2>/dev/null || {
            echo -e "${YELLOW}Note: Claude CLI not available. Using fallback health check...${NC}"
            fallback_stack_health "$target" "$report_type"
        }
    else
        echo -e "${YELLOW}Claude CLI not available. Performing basic health check...${NC}"
        fallback_stack_health "$target" "$report_type"
    fi
}

execute_build_stack() {
    local stack_name="$1"
    shift
    local options="$@"
    
    if [ -z "$stack_name" ]; then
        echo -e "${RED}Error: Stack name required${NC}"
        echo "Usage: dckr ai build-stack <stack_name> [template|existing] [options]"
        return 1
    fi
    
    echo -e "${BLUE}üèóÔ∏è  Building stack: ${YELLOW}$stack_name${NC}"
    [ -n "$options" ] && echo -e "${BLUE}Options: ${CYAN}$options${NC}"
    echo ""
    
    local prompt="Create or modify a Docker Compose stack named '$stack_name'. Please:

1. Check if the stack already exists using 'dckr stack list'
2. Based on the options '$options', determine the appropriate template or modifications
3. Generate a production-ready docker-compose.yml file with:
   - Proper service configurations
   - Security best practices
   - Appropriate networking setup
   - Volume management
   - Environment variable templates
4. Include comprehensive documentation for deployment
5. Suggest monitoring and logging setup
6. Provide deployment instructions

Follow Docker Compose best practices and security guidelines."

    if command -v claude &> /dev/null; then
        echo -e "${CYAN}Invoking Claude AI agent for stack building...${NC}"
        echo ""
        claude task --agent docker-stack-builder --prompt "$prompt" 2>/dev/null || {
            echo -e "${YELLOW}Note: Claude CLI not available. Using fallback stack builder...${NC}"
            fallback_build_stack "$stack_name" "$options"
        }
    else
        echo -e "${YELLOW}Claude CLI not available. Showing basic stack template...${NC}"
        fallback_build_stack "$stack_name" "$options"
    fi
}

execute_enhance_dckr() {
    local feature_type="$1"
    shift
    local description="$@"
    
    if [ -z "$feature_type" ] || [ -z "$description" ]; then
        echo -e "${RED}Error: Feature type and description required${NC}"
        echo "Usage: dckr ai enhance-dckr <feature_type> \"<description>\""
        return 1
    fi
    
    echo -e "${BLUE}‚ö° Enhancing dckr: ${YELLOW}$feature_type${NC}"
    echo -e "${BLUE}Description: ${CYAN}$description${NC}"
    echo ""
    
    local prompt="Enhance the dckr Docker stack manager tool. Please:

1. Read the current dckr script to understand its structure and functionality
2. Implement the requested enhancement: $feature_type - $description
3. Ensure the enhancement follows the existing code patterns and style
4. Maintain backward compatibility
5. Add appropriate error handling and user feedback
6. Update help documentation if needed
7. Test the implementation with example usage

The enhancement should integrate seamlessly with the existing enterprise-grade performance optimizations and maintain the tool's efficiency."

    if command -v claude &> /dev/null; then
        echo -e "${CYAN}Invoking Claude AI agent for dckr enhancement...${NC}"
        echo ""
        claude task --agent docker-script-enhancer --prompt "$prompt" 2>/dev/null || {
            echo -e "${YELLOW}Note: Claude CLI not available. Enhancement not implemented.${NC}"
            echo -e "${BLUE}Feature request noted: $feature_type - $description${NC}"
        }
    else
        echo -e "${YELLOW}Claude CLI not available. Enhancement not implemented.${NC}"
        echo -e "${BLUE}Feature request noted: $feature_type - $description${NC}"
    fi
}

execute_quick_fix() {
    local stack_name="$1"
    local fix_type="$2"
    
    if [ -z "$stack_name" ]; then
        echo -e "${RED}Error: Stack name required${NC}"
        echo "Usage: dckr ai quick-fix <stack_name> [fix_type]"
        return 1
    fi
    
    [ -z "$fix_type" ] && fix_type="general"
    
    echo -e "${BLUE}üîß Quick fix for: ${YELLOW}$stack_name${NC} (${CYAN}$fix_type${NC})"
    echo ""
    
    local prompt="Apply quick fixes to the Docker stack named '$stack_name'. Please:

1. Use 'dckr stack $stack_name' to assess the current state
2. Identify common issues that can be quickly resolved
3. For fix type '$fix_type', focus on appropriate solutions:
   - restart: Safe service restarts and dependency ordering
   - cleanup: Remove unused containers, volumes, and networks
   - optimize: Resource limit adjustments and performance tuning
   - security: Basic security hardening
   - general: Common maintenance and optimization tasks
4. Execute only safe, non-destructive operations
5. Provide before/after status comparison
6. Document all changes made
7. Suggest preventive measures

Be conservative - only apply fixes that are clearly safe and beneficial."

    if command -v claude &> /dev/null; then
        echo -e "${CYAN}Invoking Claude AI agent for quick fixes...${NC}"
        echo ""
        claude task --agent docker-troubleshooter --prompt "$prompt" 2>/dev/null || {
            echo -e "${YELLOW}Note: Claude CLI not available. Using fallback quick fix...${NC}"
            fallback_quick_fix "$stack_name" "$fix_type"
        }
    else
        echo -e "${YELLOW}Claude CLI not available. Performing basic maintenance...${NC}"
        fallback_quick_fix "$stack_name" "$fix_type"
    fi
}

# Fallback functions for when Claude CLI is not available
fallback_analyze_stack() {
    local stack_name="$1"
    echo -e "${BLUE}Performing basic analysis of stack: $stack_name${NC}"
    echo ""
    
    # Use the existing dckr functionality
    if .local/bin/dckr stack "$stack_name" >/dev/null 2>&1; then
        echo -e "${GREEN}‚úì Stack exists and is accessible${NC}"
        echo -e "${BLUE}Stack information:${NC}"
        .local/bin/dckr stack "$stack_name"
    else
        echo -e "${RED}‚úó Stack '$stack_name' not found${NC}"
        echo -e "${BLUE}Available stacks:${NC}"
        .local/bin/dckr stack list
    fi
}

fallback_debug_stack() {
    local stack_name="$1"
    local issue_type="$2"
    echo -e "${BLUE}Performing basic debugging of stack: $stack_name${NC}"
    [ -n "$issue_type" ] && echo -e "${BLUE}Issue type: $issue_type${NC}"
    echo ""
    
    if .local/bin/dckr stack "$stack_name" >/dev/null 2>&1; then
        echo -e "${GREEN}‚úì Stack information:${NC}"
        .local/bin/dckr stack "$stack_name"
        echo ""
        echo -e "${YELLOW}üí° Debugging suggestions:${NC}"
        echo "‚Ä¢ Check container logs: docker logs <container_name>"
        echo "‚Ä¢ Verify network connectivity between services"
        echo "‚Ä¢ Check disk space: df -h"
        echo "‚Ä¢ Monitor resource usage: docker stats"
    else
        echo -e "${RED}‚úó Stack '$stack_name' not found${NC}"
    fi
}

fallback_stack_health() {
    local target="$1"
    local report_type="$2"
    echo -e "${BLUE}Performing basic health check: $target ($report_type)${NC}"
    echo ""
    
    if [ "$target" = "all" ]; then
        echo -e "${GREEN}‚úì All stacks overview:${NC}"
        .local/bin/dckr stack list
    else
        echo -e "${GREEN}‚úì Stack health for: $target${NC}"
        .local/bin/dckr stack "$target" 2>/dev/null || echo "Stack not found"
    fi
}

fallback_build_stack() {
    local stack_name="$1"
    local options="$2"
    echo -e "${BLUE}Basic stack template for: $stack_name${NC}"
    echo -e "${BLUE}Options: $options${NC}"
    echo ""
    echo -e "${YELLOW}üìù Basic docker-compose.yml template:${NC}"
    cat << EOF
version: '3.8'
services:
  $stack_name:
    image: # specify image
    container_name: $stack_name
    restart: unless-stopped
    ports:
      - "8080:80"
    volumes:
      - ./$stack_name:/data
    environment:
      - ENV_VAR=value
networks:
  default:
    name: ${stack_name}_network
EOF
}

fallback_quick_fix() {
    local stack_name="$1"
    local fix_type="$2"
    echo -e "${BLUE}Basic maintenance for: $stack_name ($fix_type)${NC}"
    echo ""
    echo -e "${YELLOW}üí° Suggested manual fixes:${NC}"
    case "$fix_type" in
        restart)
            echo "‚Ä¢ docker-compose -p $stack_name restart"
            ;;
        cleanup)
            echo "‚Ä¢ docker system prune -f"
            echo "‚Ä¢ docker volume prune -f"
            ;;
        optimize)
            echo "‚Ä¢ Review resource limits in compose file"
            echo "‚Ä¢ Check for unused containers"
            ;;
        *)
            echo "‚Ä¢ Check logs: docker-compose -p $stack_name logs"
            echo "‚Ä¢ Restart services if needed"
            ;;
    esac
}

cmd_ai_agent() {
    local agent_name="$1"
    local prompt="$2"
    
    local agent_file="$AI_AGENTS_DIR/${agent_name}.md"
    
    if [ ! -f "$agent_file" ]; then
        echo -e "${RED}Error: AI agent '$agent_name' not found${NC}"
        echo ""
        echo -e "${YELLOW}Available agents:${NC}"
        if [ -d "$AI_AGENTS_DIR" ]; then
            ls "$AI_AGENTS_DIR" | sed 's/\.md$//' | sed 's/^/  /'
        fi
        return 1
    fi
    
    if [ -z "$prompt" ]; then
        echo -e "${RED}Error: Prompt required for agent execution${NC}"
        echo "Usage: $0 ai agent <agent_name> \"<prompt>\""
        return 1
    fi
    
    echo -e "${BLUE}ü§ñ Invoking AI Agent: ${YELLOW}$agent_name${NC}"
    echo -e "${CYAN}Prompt: ${prompt}${NC}"
    echo ""
    
    # Try to use Claude CLI to invoke the agent
    if command -v claude &> /dev/null; then
        echo -e "${CYAN}Executing Claude AI agent...${NC}"
        echo ""
        
        # Add context about the dckr tool to the prompt
        local enhanced_prompt="You are the $agent_name agent for the dckr Docker stack manager tool. 

CONTEXT: The dckr tool is located at .local/bin/dckr and provides these commands:
- dckr stack list (list all stacks)
- dckr stack <name> (detailed stack information)
- dckr ai <command> (AI-powered operations)

USER REQUEST: $prompt

Please use the appropriate tools available to you to complete this request. You can execute the dckr tool using the Bash tool, read files using the Read tool, and perform analysis using your specialized capabilities as defined in your agent description."

        claude task --agent "$agent_name" --prompt "$enhanced_prompt" 2>/dev/null || {
            echo -e "${YELLOW}Note: Claude CLI execution failed. Showing agent info instead.${NC}"
            show_agent_info "$agent_file"
        }
    else
        echo -e "${YELLOW}Claude CLI not available. Showing agent information:${NC}"
        show_agent_info "$agent_file"
    fi
}

show_agent_info() {
    local agent_file="$1"
    
    # Show agent description
    local description=$(grep "^## Description" "$agent_file" | sed 's/^## Description[[:space:]]*//')
    echo -e "${YELLOW}Agent Description:${NC} $description"
    echo ""
    
    # Show agent responsibilities
    echo -e "${YELLOW}Primary Responsibilities:${NC}"
    sed -n '/^### /p' "$agent_file" | sed 's/^### /  ‚Ä¢ /'
    echo ""
    
    echo -e "${BLUE}üí° This agent would analyze your request and provide specialized assistance${NC}"
}

cmd_ai_dispatch() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        help|--help|-h|"")
            show_ai_help
            ;;
        agent)
            cmd_ai_agent "$@"
            ;;
        analyze-stack|build-stack|debug-stack|enhance-dckr|quick-fix|stack-health)
            cmd_ai_command "$subcommand" "$@"
            ;;
        *)
            echo -e "${RED}Error: Unknown AI command '$subcommand'${NC}"
            echo ""
            show_ai_help
            return 1
            ;;
    esac
}

show_performance_stats() {
    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $START_TIME" | bc)
    echo ""
    echo -e "${BLUE}Performance: ${GREEN}${API_CALL_COUNT} API calls${NC} in ${GREEN}${duration}s${NC}"
    if [ "$HAS_JQ" = true ]; then
        echo -e "${BLUE}Parser: ${GREEN}jq (optimized)${NC}"
    else
        echo -e "${BLUE}Parser: ${YELLOW}grep/sed (fallback)${NC}"
    fi
}

show_usage() {
    echo -e "${BOLD}Docker Stack Manager - Enterprise Edition${NC}"
    echo ""
    echo "Usage: $0 <command> [options]"
    echo ""
    echo -e "${YELLOW}Commands:${NC}"
    echo "  stack list              List all Docker Compose stacks"
    echo "  stack <name>            Show detailed information for a stack"
    echo "  ai <command> [args]     AI-powered stack management and troubleshooting"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  $0 stack list"
    echo "  $0 stack radarr"
    echo "  $0 ai help"
    echo "  $0 ai analyze-stack media"
    echo "  $0 ai debug-stack authentik network"
    echo ""
    echo -e "${YELLOW}AI Features:${NC}"
    echo "  ‚Ä¢ Intelligent stack analysis and optimization"
    echo "  ‚Ä¢ Automated troubleshooting and debugging"
    echo "  ‚Ä¢ AI-powered configuration generation"
    echo "  ‚Ä¢ Performance monitoring and recommendations"
    echo ""
    echo -e "${YELLOW}Performance:${NC}"
    echo "  ‚Ä¢ Optimized with parallel processing"
    echo "  ‚Ä¢ Minimal API calls"
    echo "  ‚Ä¢ jq support for faster JSON parsing"
    echo ""
}

# Main command dispatcher
COMMAND="$1"
shift

case "$COMMAND" in
    stack)
        SUBCOMMAND="$1"
        shift
        case "$SUBCOMMAND" in
            list)
                cmd_stack_list
                ;;
            *)
                cmd_stack_info "$SUBCOMMAND"
                ;;
        esac
        ;;
    ai)
        cmd_ai_dispatch "$@"
        ;;
    help|--help|-h|"")
        show_usage
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$COMMAND'${NC}"
        echo ""
        show_usage
        exit 1
        ;;
esac